# 11-21~11-27

## 1、数据类型

### 基本数据类型

- string
- number
- boolean
- undefined
- null
- symbol

### 引用数据类型

- object
- array
- function
- date
- ...

#### 区别：

| 不同         | 基本数据类型                 | 引用数据类型                              |
| ------------ | ---------------------------- | ----------------------------------------- |
| 存储方式     | 栈                           | 堆                                        |
| 复制方式     | 复制值（完全独立）           | 复制地址（指针相同）                      |
| 访问方式     | 按值访问                     | 按地址访问                                |
| 判断类型方式 | typeof（数组和对象不能区分） | instanceof/Object.prototype.toString.call |

## 2、上下文与作用域

### 上下文

- 定义：是变量和函数能够访问到的对象。在执行完毕（应用退出，网页关闭）后会随之销毁。
- 全局上下文：常见的 window 对象，可以通用 var 声明使变量、函数成文全局上下文的属性和方法。
- 函数上下文：函数的上下文。执行时，会被推到上下文栈，执行完毕会被弹出。
- 块级上下文：{}包裹的代码块。

### 作用域链

- 定义：上下文代码在访问变量和函数时的顺序和依赖关系
- 作用域链增强：在当前作用域链之前插入一个新的临时上下文，常见：trycatch 的 catch、with
- 补充：对于函数上下文，最初的上下文是 arguments；代码执行的上下文始终在最前端，从里到外，依次排序。查询是从前往后的顺序进行。

### 变量声明

区别：

- var：

  - 变量\函数提升：在最近的上下文的最前面添加变量
  - 当未声明变量，直接初始化，则添加到全局上下文

- let：
  - 适用于块级作用域，{}包裹的代码
  - 不能重复声明
  - 不会有提升效果，形成暂时性死区
- const：
  - 不能重复声明
  - 不能更改，但可以更改对象的键值对
  - 没有提升效果

## 3、垃圾回收机制

- 原理：哪个变量不使用，就释放它占用的内存。
- 实现方法：标记清除、引用计数
- 标记清除：
  实现：按照策略（不止一种），给变量加上标记，如：给变量加上进入上下文、离开上下文的标记，最后垃圾回收程序将指定标记的变量释放内存。
- 引用计数：
  实现：记录每个值的引用次数，当声明并赋值给别的变量时，次数+1，当别的变量赋值给 引用它的变量 的时候，次数-1，当次数等于 0 时，就释放内存。
  问题：循环引用，当两个对象各自包含对方的引用，次数永远为 2，永不释放内存，需要手动解除引用，令其为 null。

## 4、内存泄漏

- 原因：
  - 意外的全局变量声明，不加声明符号
  - 定时器
  - dom 操作
  - 闭包

## 5、原型、原型链

- 原型定义：函数上的 prototype 属性，其中包含特定引用类型实例的属性和方法。

- 原型链定义：通过一个原型去查找另一个原型上的实例和方法的依赖关系。

- 补充：
  - 原型链的最底层是 null

## 6、函数

### 箭头函数

- 定义：使用 => 的形式声明函数的函数。
- 优点：简单
- 缺点：
  - 没有 arguments、super
  - 不能作构造函数
  - this 指向外层上下文
  - 没有原型，prototype
