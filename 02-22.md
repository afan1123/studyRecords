## 性能

### 前端性能优化指标 RAIL

- 定义：R 为 response 响应 A 为 animation 动画 I 为 Idle 空闲 L 为 load 加载
  - R：处理时间 50ms 以内，超过 50ms 为长任务
  - A：1/60fps
  - I：尽可能的增加空闲时间，来响应用户的操作（计算相关让后端完成）
  - L：5s 内完成所有内容加载并且可以交互

### 前端性能优化手段

- webpack 优化
- 图片加载
- 重绘回流
- 防抖节流

### 重排和重绘（同上）

### 白屏优化

- 原因：浏览器发送请求时，需要将用户输入的域名地址转换为 IP 地址，这个时间太长就会出现白屏
- 解决方案：
  - DNS 查询优化：<meta http-quiv='x-dns-prefetch-control' content='on'><link ref='dns-prefetch' href='http://www.baidu.com'>
  - 使用骨架屏

### 大量图片加载优化

- 使用图片服务器，否则浏览器会因为高 I/O 负载而崩溃
- 项目中使用图片压缩再上传
- 图片懒加载，当可视区域需要图片时，再加载
- 使用雪碧图、字体图标、base64 来有效减少连接数
- http2 解决了连接数限制。每个请求为一个流，每个请求被分为多个二进制帧，不同流可以交错发送，实现多路复用。

### 图片过大优化

- link 的 perload 属性。 <link rel='preload' href='./img/01.png' as='image'>
- 图片拆分。
- 图片的 onload 事件。先选一张默认图进行展示，当图片触发 onlad 事件即完成加载后，替换图片。
- 转 base64

### 动画性能

- 背景：浏览器的渲染进程是多线程的，主要有两个线程：GUI 线程和 js 线程
- GUI 线程：

  - 负责解析 HTML,CSS,合成 DOM 树，Render 树，布局和绘制等
  - 当界面重绘回流时，该线程就会执行
  - 与 JS 线程执行时，GUI 线程会阻塞，等到 JS 执行完后再执行该线程

- 合格的动画：每秒 30-60 帧的动画会让人感到流畅
- 渲染过程：
  - 解析 html，形成 DOM 树
  - 解析 CSS，形成 CSSOM 树
  - 合成 Render 树
  - 布局 Render 树，负责元素的位置，大小等计算（回流发生阶段）
  - 绘制 Render 树，负责页面像素信息（重绘发生阶段）
  - 将各层信息发送给 GPU（GPU 进程），GPU 将各层信息显示在屏幕上
- GPU 做的事：

  - 绘制位图到屏幕上
  - 可不断的绘制相同的位图
  - 将同一位图进行位移、旋转和缩放

- GPU 与 CPU 的渲染区别：
  - GPU：更适合 3D 渲染，因为对图形计算和并行处理进行了优化，且渲染任务容易并行操作，还有上千个内核。
  - CPU：串行操作，只有 64 个内核
- 渲染层：当 DOM 树中的节点都会对应一个渲染对象，当渲染对象处于同一个 Z 轴坐标时，就会形成 RenderLayer（渲染层），以保证正确的顺序堆叠。
- 图形层：生成一个最终呈现内容图形的层模型，有一个图形上下文，负责输出该层的位图。存储在共享内存的位图将交给 GPU 进行合成，最后显示到屏幕上
- 合成层：满足特殊条件的渲染层，称之为合成层。拥有单独的图形层。
  - 特殊条件：
    - 3Dtransforms
    - video，canvas，iframe 等
    - CSS 动画实现的 opacity 动画转换
    - position:fixed
    - 具有 will-change 的属性
    - 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition
- 将渲染层提升为合成层的方式：
  - 进行 3D 或者透明转换的 CSS 属性
  - 具有 3d（WebGL）上下文或者硬件加速的 2d 上下文的元素
  - 组合型插件（flash）
  - CSS3 的转换或者动画属性
  - 使用了硬件加速的 CSS filters 技术
- 提升为合成层的优势：
  - 合成层的位图，会交给 GPU 处理，比 CPU 快
  - 当需要重绘时，只需要重绘本身层，不影响其他层
  - 对于 transform 和 opacity 效果，不会触发 layout 和 paint
