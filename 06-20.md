# JS 原理

## Just-In-Time 优化原理与最佳实践

- 定义：即时编译器，可以将动态解释的代码转换为本机代码的技术，即一边编译一边执行
  - 动态解释的代码：在运行时根据上下文和环境进行解释和执行的代码。常见于动态语言，如 JS 和脚本语言
- 作用：转换成本机代码后，在下一次代码执行时直接运行编译后的本机代码，而不需要再进行解释和编译，提高了代码的性能和响应时间
- 使用场景：
  - 除了 Javascript，还可以作用于虚拟机，java 虚拟机，.net 虚拟机
  - vue3：@vue/compiler-sfc
- 原理：
  1. 分析器阶段：在 JS 引擎中增加代码分析器，监视代码运行情况，若一段代码运行了几次，则标记 warm；若运行了多次，则标记 hot
  2. 基线编译器阶段：如果一段代码变成了 “warm”，那么 JIT 就把它送到基线编译器去编译，并且把编译结果存储起来。比如，监视器监视到了，某行、某个变量执行同样的代码、使用了同样的变量类型，那么就会把编译后的版本，替换掉这一行代码，并且存储。
     - 基线编译器：用于将高级语言代码转换为机器代码。
  3. 优化编译器阶段：如果一个代码变成 “hot”，监视器会把它发送到优化编译器中。生成一个更快速和高效的代码版本出来，并且存储
     - 优化编译器：利用各种技术和算法来改进代码的执行速度、内存利用率和资源消耗
  4. 去优化阶段：我们在使用优化编译器的时候，总是会有一些假设的，如果这些假设无效，就说明我们之前的优化操作并不可取，所以需要去优化，去掉我们需要优化的方法
- 简单对比 AOT（运行时编译器）
  - 定义：在编译全部完成之后，再去宿主环境中执行
  - 使用方案：
    - React:jsx/模板语法
    - SolidJS：jsx
    - Svelte：模板语法

## 常见模块化(ESM、CMD、AMD)方案，与他们之间的差异

### ESM

- 支持静态导入导出语法，即 import 和 export
- 在编译时支持静态分析，所以可以支持 tree-shaking
- 支持异步加载模块与动态导入
- 所有的加载都是值的引入，所以才能支持静态分析

### CommonJS

- 支持 require 将模块导入，用 exports 和 module.exports 对模块导出
- 支持同步加载模块，会导致模块阻塞
- 第一次被加载时，会被缓存，之后都从缓存中直接读取结果。
- 引入该模块的 module.exports 属性，该属性输出的是值拷贝，一旦这个值被输出，模块内再发生变化不会影响到输出的值。

### AMD

- 用 define 定义模块，用 require 异步加载模块
- 用于解决浏览器的异步加载模块问题

## 疑问

- vue2 和 vue3 分别采用了什么编译方式（aot/jit）
- 实践应该怎么实践
