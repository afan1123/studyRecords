## 单线程模型

- 定义：js 引擎中负责解释和执行的 JS 代码中的线程唯一，同一时间上只能执行一件任务。
- 背景：为了应对以下情况即多次修改 DOM，导致 DOM 修改和渲染的冲突的出现，就需要依次执行任务，就设计了单线程。
  - 浏览器渲染 DOM
  - JS 可以修改 DOM
  - 当 JS 修改 DOM，浏览器 DOM 渲染停止

### webworker

- 定义：为了应对单线程的缺陷，推出了 webworker，允许 js 创建多了子线程
- 缺陷：子线程完全受主线程控制，且不得操作 DOM 子线程完全受主线程控制，且不得操作 DOM

### Event Loop（事件循环）

- 背景：为了应对 IO 设备慢，导致后面任务等待时间长的问题，推出了事件循环
- 定义：之前讲了，就不赘述了

### 消息队列

- 定义：事件循环中的任务队列就是消息队列，里面存储着拥有回调函数的各种消息
- 注意：要是没有回调函数，是不会进入消息队列的

## DOM 与 JS 跨线程通讯原理

- 背景：
  - JS 引擎只会操作 JS，渲染引擎只会操作渲染页面，两者都是线程，所以需要跨线程通信
  - 为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起，
    GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。
- 原理：

  ```js
  let div = document.createElement('div');
  div.innerText = 'hi';
  document.body.appendChild('div'); //将div添加到body中
  div.innerText = 'frank';
  /*
  在 div 被加入页面之前，创建 div 和修改 div 的 innerText 的操作都属于JS 线程内的操作，不涉及渲染操作。
  当把 div 放入页面之时，浏览器会发现 JS 的意图，就会通知渲染线程在页面中渲染出一个 div 元素，该元素的属性都照抄 JS 中的 div 对象。
  当 div 元素被渲染到页面后，对 div 的 innerText 属性做出的修改时，页面会重新渲染。
  如果连续对 div 进行多次操作，浏览器 可能 会合并成一次操作
  当我们对JS中的元素节点的属性进行操作修改时，有些属性会被同步到页面中，而有些则不会:
    标准属性会被同步:id,class,title,label
    data- 属性会被同步:data-hh,data-dsoadja
    非标准的属性（自定义属性）不会被同步到页面上，只会停留在JS引擎中
  */
  ```

## 浏览器进程模型

1. 浏览器进程：这是浏览器的主进程，负责管理和协调其他进程。它处理用户界面、用户输入、网络请求、插件管理等任务。
2. 渲染进程：每个标签页或窗口都有一个独立的渲染进程，用于解析和渲染网页内容。渲染进程负责处理 HTML、CSS、JavaScript，并将网页呈现到用户界面上。
3. GPU 进程：该进程负责处理与图形相关的任务，例如渲染页面中的图形和动画效果。它通过与操作系统的图形驱动程序进行交互，加速页面的绘制和渲染。
4. 插件进程：对于使用插件的网页，浏览器会为每个插件创建一个独立的进程，以确保插件的安全性和稳定性。
5. 网络进程：该进程负责处理网络请求，包括与服务器的通信、下载文件等。它与浏览器进程和渲染进程进行通信，传输网络数据。

- 特点：
  - 是资源分配的最小单位
  - 每个进程都是相互独立的，拥有自己的内存空间，这样可以提高安全性和稳定性。进程之间通过进程间通信进行数据交换和协调。
  - 浏览器的进程模型可以有效隔离不同的任务，当一个进程出现问题时，不会影响其他进程的正常运行。

## 浏览器线程模型

- 种类：
  1. 主线程：负责处理用户交互、渲染页面和执行 JavaScript 代码。
  2. js 引擎线程：负责解析和执行 JavaScript 代码
  3. 定时器线程：负责管理定时器
  4. 事件线程：负责处理事件，例如鼠标点击、键盘输入、网络请求等等
  5. web worker 线程：Web Worker 是一种在后台运行的 JavaScript 线程，用于执行耗时的计算任务，以避免阻塞主线程。
- 特点：
  - 线程之间通过消息队列进行通信，所以是异步的
  - 是资源执行的的最小单位

## 页面渲染流程

1. 解析 html：开始解析 HTML 代码，构建 DOM 树
2. 解析 css：开始解析 CSS 代码，构建 CSSOM 树
3. 合成 render 树：将 DOM 树和 CSSOM 树结合起来，构建渲染树（Render Tree）
4. layout 布局计算：根据盒模型计算每个元素在页面中的位置和大小，确定布局（重排阶段）
5. 绘制：布局计算完成后，浏览器开始将渲染树中的每个元素绘制到屏幕上。（重绘阶段）
6. 合成显示：浏览器对绘制的结果进行合成，并在屏幕上显示

- 注意：
  - 期间遇到 js 执行，会阻塞渲染，等到 js 执行完成之后，再开始渲染

### GPU 加速

- 定义：使用 opacity/translate 等 css 属性，将元素交给 gpu 进行加速
- 作用：加速能有效减少重排重绘
- 原理：gpu 会把某些元素单独抽离形成独立的合成层，这些合成层能在 gpu 上单独进行渲染和处理不会影响其他元素的重绘重排

### RAF 和 RIC

- RAF（reqiestAnimationFrame）
  - 定义:浏览器提供的用于在下一次重绘之前执行回调函数的 API
  - 原理：回调函数会在浏览器完成上一帧的渲染后执行，通常是每秒 60 帧，执行时机与浏览器的刷新频率同步
  - 使用场景：用于执行高性能的动画和实时更新的操作
- RIC（requestIdleCallback）
  - 定义：浏览器提供的用于在主线程空闲时执行回调函数的 API
  - 原理：在主线程空闲时执行，回调函数通常用于执行一些不需要立即完成的低优先级任务
  - 使用场景：用于执行一些低优先级的任务
